{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../src/RectangleDrawer.svelte",
    "../src/KonvaDrawer.svelte"
  ],
  "sourcesContent": [
    "<script>\n\n\tlet i = 0;\n\tlet numRects = 1;\n\tlet undoStack = [[]];\n\tlet rects = [];\n\tlet selected;\n\tlet adjusting = false;\n\tlet adjusted = false;\n\n\tfunction handleClick(event) {\n\t\tif (adjusting) {\n\t\t\tadjusting = false;\n\n\t\t\t// if rect was adjusted,\n\t\t\t// push to the stack\n\t\t\tif (adjusted) push();\n\t\t\treturn;\n\t\t}\n\n\t\tconst rect = {\n\t\t\tname: `box-${numRects}`,\n\t\t\tx: event.clientX,\n\t\t\ty: event.clientY,\n\t\t\twidth: 50,\n\t\t\theight: 50,\n\t\t};\n\n\t\trects = rects.concat(rect);\n\t\tselected = rect;\n\n\t\tpush();\n\t\tnumRects++;\n\t}\n\n\tfunction adjust(event) {\n\t\tselected.width = +event.target.value;\n\t\trects = rects;\n\t\tadjusted = true;\n\t}\n\n\tfunction select(rect, event) {\n\t\tif (!adjusting) {\n\t\t\tevent.stopPropagation();\n\t\t\tselected = rect;\n\t\t}\n\t}\n\n\tfunction push() {\n\t\tconst newUndoStack = undoStack.slice(0, ++i);\n\t\tnewUndoStack.push(clone(rects));\n\t\tundoStack = newUndoStack;\n\t}\n\n\tfunction travel(d) {\n\t\trects = clone(undoStack[i += d]);\n\t\tadjusting = false;\n\t}\n\n\tfunction clone(rects) {\n\t\treturn rects.map(({ name, x, y, width, height }) => ({ name, x, y, width, height }));\n\t}\n</script>\n\n<style>\n\t.controls {\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\ttext-align: center;\n\t}\n\n\tsvg {\n\t\tbackground-color: #eee;\n\t\tposition: absolute;\n    \twidth: 100%;\n\t\theight: 100%;\n\t}\n\n\trect {\n\t\tstroke: black;\n\t}\n\n\t.adjuster {\n\t\tposition: absolute;\n\t\twidth: 80%;\n\t\ttop: 10%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%,-50%);\n\t\tpadding: 1em;\n\t\ttext-align: center;\n\t\tbackground-color: rgba(255,255,255,0.7);\n\t\tborder-radius: 4px;\n\t}\n\n\tinput[type='range'] {\n\t\twidth: 100%;\n\t}\n</style>\n\n<div>\n<div class=\"controls\">\n\t<button on:click=\"{() => travel(-1)}\" disabled=\"{i === 0}\">undo</button>\n\t<button on:click=\"{() => travel(+1)}\" disabled=\"{i === undoStack.length -1}\">redo</button>\n</div>\n\n<svg on:click={handleClick} >\n\t{#each rects as rect}\n\t\t<rect \n\t\t\tx={rect.x} \n\t\t\ty={rect.y} \n\t\t\twidth={rect.width}\n\t\t\theight={rect.height} \n\t\t\ton:click=\"{event => select(rect, event)}\"\n\t\t\ton:contextmenu|stopPropagation|preventDefault=\"{() => {\n\t\t\t\tadjusting = !adjusting;\n\t\t\t\tif (adjusting) selected = rect;\n\t\t\t}}\"\n\t\t\tfill=\"{rect === selected ? '#ccc': 'white'}\"\n\t\t/>\n\t{/each}\n</svg>\n\n{#if adjusting}\n\t<div class=\"adjuster\">\n\t\t<p>adjust width of {selected.name} at {selected.x}, {selected.y}, {selected.width}, {selected.height}\n\t\t</p>\n\t\t<input type=\"range\" value={selected.width} on:input={adjust}>\n\t</div>\n{/if}\n</div>\n",
    "<body>\n<script>\nimport Konva from 'konva';\nimport { onMount } from 'svelte';\n\nonMount(() => {\n    var width = window.innerWidth;\n    var height = window.innerHeight;\n    var GUIDELINE_OFFSET = 5;\n    // first we need to create a stage\n    var stage = new Konva.Stage({\n        container: 'konva-stage',   // id of container <div>\n        width: width,\n        height: height,        \n    });\n\n    // then create layer\n    var layer = new Konva.Layer();\n\n    // first generate random rectangles\n    for (var i = 0; i < 5; i++) {\n      layer.add(\n        new Konva.Rect({\n          x: Math.random() * stage.width(),\n          y: Math.random() * stage.height(),\n          width: 50 + Math.random() * 50,\n          height: 50 + Math.random() * 50,\n          fill: Konva.Util.getRandomColor(),\n          rotation: Math.random() * 360,\n          draggable: true,\n          name: 'object'\n        })\n      );\n    }\n\n    // were can we snap our objects?\n    function getLineGuideStops(skipShape) {\n        // we can snap to stage borders and the center of the stage\n        var vertical = [0, stage.width() / 2, stage.width()];\n        var horizontal = [0, stage.height() / 2, stage.height()];\n\n        // and we snap over edges and center of each object on the canvas\n        stage.find('.object').forEach(guideItem => {\n          if (guideItem === skipShape) {\n            return;\n          }\n          var box = guideItem.getClientRect();\n          // and we can snap to all edges of shapes\n          vertical.push([box.x, box.x + box.width, box.x + box.width / 2]);\n          horizontal.push([box.y, box.y + box.height, box.y + box.height / 2]);\n        });\n        return {\n          vertical: vertical.flat(),\n          horizontal: horizontal.flat()\n        };\n      }\n\n      // what points of the object will trigger to snapping?\n      // it can be just center of the object\n      // but we will enable all edges and center\n    function getObjectSnappingEdges(node) {\n        var box = node.getClientRect();\n        return {\n          vertical: [\n            {\n              guide: Math.round(box.x),\n              offset: Math.round(node.x() - box.x),\n              snap: 'start'\n            },\n            {\n              guide: Math.round(box.x + box.width / 2),\n              offset: Math.round(node.x() - box.x - box.width / 2),\n              snap: 'center'\n            },\n            {\n              guide: Math.round(box.x + box.width),\n              offset: Math.round(node.x() - box.x - box.width),\n              snap: 'end'\n            }\n          ],\n          horizontal: [\n            {\n              guide: Math.round(box.y),\n              offset: Math.round(node.y() - box.y),\n              snap: 'start'\n            },\n            {\n              guide: Math.round(box.y + box.height / 2),\n              offset: Math.round(node.y() - box.y - box.height / 2),\n              snap: 'center'\n            },\n            {\n              guide: Math.round(box.y + box.height),\n              offset: Math.round(node.y() - box.y - box.height),\n              snap: 'end'\n            }\n          ]\n        };\n      }\n\n      // find all snapping possibilities\n    function getGuides(lineGuideStops, itemBounds) {\n        var resultV = [];\n        var resultH = [];\n\n        lineGuideStops.vertical.forEach(lineGuide => {\n          itemBounds.vertical.forEach(itemBound => {\n            var diff = Math.abs(lineGuide - itemBound.guide);\n            // if the distance between guild line and object snap point is close we can consider this for snapping\n            if (diff < GUIDELINE_OFFSET) {\n              resultV.push({\n                lineGuide: lineGuide,\n                diff: diff,\n                snap: itemBound.snap,\n                offset: itemBound.offset\n              });\n            }\n          });\n        });\n\n        lineGuideStops.horizontal.forEach(lineGuide => {\n          itemBounds.horizontal.forEach(itemBound => {\n            var diff = Math.abs(lineGuide - itemBound.guide);\n            if (diff < GUIDELINE_OFFSET) {\n              resultH.push({\n                lineGuide: lineGuide,\n                diff: diff,\n                snap: itemBound.snap,\n                offset: itemBound.offset\n              });\n            }\n          });\n        });\n\n      var guides = [];\n\n        // find closest snap\n      var minV = resultV.sort((a, b) => a.diff - b.diff)[0];\n      var minH = resultH.sort((a, b) => a.diff - b.diff)[0];\n      if (minV) {\n          guides.push({\n            lineGuide: minV.lineGuide,\n            offset: minV.offset,\n            orientation: 'V',\n            snap: minV.snap\n          });\n        }\n      if (minH) {\n          guides.push({\n            lineGuide: minH.lineGuide,\n            offset: minH.offset,\n            orientation: 'H',\n            snap: minH.snap\n          });\n        }\n      return guides;\n    }\n\n    function drawGuides(guides) {\n        guides.forEach(lg => {\n          if (lg.orientation === 'H') {\n            var line = new Konva.Line({\n              points: [-6000, lg.lineGuide, 6000, lg.lineGuide],\n              stroke: 'rgb(0, 161, 255)',\n              strokeWidth: 1,\n              name: 'guid-line',\n              dash: [4, 6]\n            });\n            layer.add(line);\n            layer.batchDraw();\n          } else if (lg.orientation === 'V') {\n            var line = new Konva.Line({\n              points: [lg.lineGuide, -6000, lg.lineGuide, 6000],\n              stroke: 'rgb(0, 161, 255)',\n              strokeWidth: 1,\n              name: 'guid-line',\n              dash: [4, 6]\n            });\n            layer.add(line);\n            layer.batchDraw();\n          }\n        });\n      }\n\n    layer.on('dragmove', function(e) {\n        // clear all previous lines on the screen\n        layer.find('.guid-line').destroy();\n\n        // find possible snapping lines\n        var lineGuideStops = getLineGuideStops(e.target);\n        // find snapping points of current object\n        var itemBounds = getObjectSnappingEdges(e.target);\n\n        // now find where can we snap current object\n        var guides = getGuides(lineGuideStops, itemBounds);\n\n        // do nothing of no snapping\n        if (!guides.length) {\n          return;\n        }\n\n    drawGuides(guides);\n\n    // now force object position\n    guides.forEach(lg => {\n          switch (lg.snap) {\n            case 'start': {\n              switch (lg.orientation) {\n                case 'V': {\n                  e.target.x(lg.lineGuide + lg.offset);\n                  break;\n                }\n                case 'H': {\n                  e.target.y(lg.lineGuide + lg.offset);\n                  break;\n                }\n              }\n              break;\n            }\n            case 'center': {\n              switch (lg.orientation) {\n                case 'V': {\n                  e.target.x(lg.lineGuide + lg.offset);\n                  break;\n                }\n                case 'H': {\n                  e.target.y(lg.lineGuide + lg.offset);\n                  break;\n                }\n              }\n              break;\n            }\n            case 'end': {\n              switch (lg.orientation) {\n                case 'V': {\n                  e.target.x(lg.lineGuide + lg.offset);\n                  break;\n                }\n                case 'H': {\n                  e.target.y(lg.lineGuide + lg.offset);\n                  break;\n                }\n              }\n              break;\n            }\n          }\n        });\n      });\n\n    layer.on('dragend', function(e) {\n        // clear all previous lines on the screen\n        layer.find('.guid-line').destroy();\n        layer.batchDraw();\n      });\n\n    layer.draw();\n\n\n    stage.on('click tap', function(e) {\n        // if click on empty area - remove all transformers\n        if (e.target === stage) {\n          stage.find('Transformer').destroy();\n          layer.draw();\n          return;\n        }\n        // do nothing if clicked NOT on our rectangles\n        if (!e.target.hasName('object')) {\n          return;\n        }\n        // remove old transformers\n        // TODO: we can skip it if current rect is already selected\n        stage.find('Transformer').destroy();\n\n        // create new transformer\n        var tr = new Konva.Transformer();\n        layer.add(tr);\n        tr.attachTo(e.target);\n        layer.draw();\n      });\n\n      // add the layer to the stage\n    stage.add(layer);\n\n    // draw the image\n    layer.draw();\n});\n\n</script>\n</body>\n\n<style>\n  body {\n        margin: 0;\n        padding: 0;\n        overflow: hidden;\n        background-color: black;\n      }\n</style>\n\n<div>\n    <div id=\"konva-stage\"></div>\n</div>\n"
  ],
  "names": [],
  "mappings": "AAiEC,SAAS,cAAC,CAAC,AACV,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,AACnB,CAAC,AAED,GAAG,cAAC,CAAC,AACJ,gBAAgB,CAAE,IAAI,CACtB,QAAQ,CAAE,QAAQ,CACf,KAAK,CAAE,IAAI,CACd,MAAM,CAAE,IAAI,AACb,CAAC,AAED,IAAI,cAAC,CAAC,AACL,MAAM,CAAE,KAAK,AACd,CAAC,AAED,SAAS,cAAC,CAAC,AACV,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,GAAG,CACV,GAAG,CAAE,GAAG,CACR,IAAI,CAAE,GAAG,CACT,SAAS,CAAE,UAAU,IAAI,CAAC,IAAI,CAAC,CAC/B,OAAO,CAAE,GAAG,CACZ,UAAU,CAAE,MAAM,CAClB,gBAAgB,CAAE,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CACvC,aAAa,CAAE,GAAG,AACnB,CAAC,AAED,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,cAAC,CAAC,AACpB,KAAK,CAAE,IAAI,AACZ,CAAC;ACmMA,IAAI,cAAC,CAAC,AACA,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,QAAQ,CAAE,MAAM,CAChB,gBAAgB,CAAE,KAAK,AACzB,CAAC"
}